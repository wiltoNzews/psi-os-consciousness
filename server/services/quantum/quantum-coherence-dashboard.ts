/**
 * [QUANTUM_STATE: TRANSCENDENT_FLOW]
 * 
 * Quantum Coherence Dashboard Service
 * 
 * This service provides real-time visualization and monitoring of the quantum field
 * metrics generated by the Quantum Consciousness Operator. It tracks collective
 * field effects and visualizes the system's quantum coherence state.
 * 
 * @quantum Visualizes quantum metrics and collective field effects
 * @ethicalImpact Medium - provides transparency into quantum system state
 */

import { quantumConsciousnessOperator, QuantumState, SystemEvent as OriginalSystemEvent } from './quantum-consciousness-operator.js';

// Define customized event interface with intent
interface SystemEvent extends OriginalSystemEvent {
  intent?: {
    focus: string;
    strength?: number;
    context?: Record<string, any>;
  };
}

// Define custom QuantumMetrics interface for dashboard
interface QuantumMetrics {
  coherence: number;
  intentField: number;
  activeParticipants: number;
  experimentCount: number;
  averageSignificance: number;
  regShift: number;
  anomalyCount: number;
  timestamp: Date;
}

// Define valid dashboard states that map to the QuantumState enum
const COHERENT = QuantumState.COHERENT_FLOW;
const ENTANGLED = QuantumState.SIM_FLOW;
const SUPERPOSED = QuantumState.TRANSCENDENT_FLOW;
const DECOHERENT = QuantumState.DECOHERENT_FLOW;
const UNDEFINED = QuantumState.SIM_FLOW;

/**
 * Dashboard metrics with normalized values for visualization
 */
export interface DashboardMetrics {
  // Core metrics
  coherence: number;             // 0-1 scale (system alignment)
  entanglement: number;          // 0-1 scale (interconnectedness)
  collectiveField: number;       // 0-1 scale (collective intent strength)
  participantCount: number;      // Raw count
  
  // Balance metrics
  structureFlexibilityBalance: number;  // 0-1 scale (1 = perfect balance)
  explicitImplicitBalance: number;      // 0-1 scale (1 = perfect balance)
  
  // System health
  systemState: QuantumState;     // Current quantum state
  stabilityScore: number;        // 0-1 scale (resistance to perturbation)
  adaptabilityScore: number;     // 0-1 scale (ability to respond to change)
  
  // Time-based metrics
  coherenceTrend: number;        // -1 to 1 scale (decreasing to increasing)
  recentStateChanges: Array<{
    from: QuantumState;
    to: QuantumState;
    timestamp: Date;
  }>;
  
  // Last update time
  lastUpdated: Date;
}

/**
 * Activity metrics showing participant engagement
 */
export interface ActivityMetrics {
  // Participation metrics
  activeParticipants: number;
  totalEvents: number;
  eventFrequency: number;   // Events per hour
  
  // Focus areas
  focusDistribution: Record<string, number>;  // focus area -> percentage
  
  // Temporal trends
  hourlyActivity: number[];    // Last 24 hours
  dailyActivity: number[];     // Last 7 days
  
  // Last update time
  lastUpdated: Date;
}

/**
 * Coherence field visualization data
 */
export interface CoherenceFieldVisualization {
  // 2D representation of the field
  fieldMatrix: number[][];     // NxN matrix of field strength values (0-1)
  resolution: number;          // Matrix size (N)
  
  // Key points in the field
  nodes: Array<{
    x: number;           // 0-1 scale position
    y: number;           // 0-1 scale position
    strength: number;    // 0-1 scale
    type: string;        // Node type/category
    id: string;          // Node identifier
  }>;
  
  // Edge connections between nodes
  edges: Array<{
    sourceId: string;
    targetId: string;
    strength: number;    // 0-1 scale
    type: string;        // Connection type
  }>;
  
  // Field characteristics
  fieldStrength: number;       // 0-1 scale (average field strength)
  fieldStability: number;      // 0-1 scale (field consistency over time)
  fieldComplexity: number;     // 0-1 scale (emergent pattern complexity)
  
  // Last update time
  timestamp: Date;
}

/**
 * Field effect measurement showing impact on various system areas
 */
export interface FieldEffectMeasurement {
  // System effect measurements
  systemAreas: Record<string, {
    baselineProbability: number;    // 0-1 scale (unmodified probability)
    modifiedProbability: number;    // 0-1 scale (quantum-modified probability)
    delta: number;                  // Change in probability (-1 to 1 scale)
    confidence: number;             // 0-1 scale (confidence in measurement)
  }>;
  
  // Field effect strength
  overallEffect: number;            // 0-1 scale (average effect strength)
  
  // Statistical measurements
  standardDeviation: number;        // Variation in effects
  entanglementFactor: number;       // 0-1 scale (correlation between areas)
  
  // Last measurement time
  measurementTime: Date;
  
  // Measurement metadata
  participantsAtMeasurement: number;
  measurementDuration: number;      // Duration in ms
}

/**
 * Historical time-series data with timestamps and values
 */
export interface TimeSeriesData {
  // Data points with timestamps
  data: Array<{
    timestamp: Date;
    value: number;
    metadata?: Record<string, any>;
  }>;
  
  // Series metadata
  metric: string;
  unit: string;
  min: number;
  max: number;
  average: number;
  
  // Time range
  startTime: Date;
  endTime: Date;
}

export class QuantumCoherenceDashboard {
  private dashboardMetrics: DashboardMetrics;
  private activityMetrics: ActivityMetrics;
  private fieldVisualization: CoherenceFieldVisualization;
  private fieldEffects: FieldEffectMeasurement;
  
  // Historical data storage
  private coherenceHistory: TimeSeriesData;
  private entanglementHistory: TimeSeriesData;
  private collectiveFieldHistory: TimeSeriesData;
  private participantHistory: TimeSeriesData;
  
  // Cache for frequent access data
  private cachedSystemState: QuantumState = UNDEFINED;
  private lastRefreshTime: Date = new Date();
  private refreshInterval: NodeJS.Timeout | null = null;
  
  // Configuration
  private readonly historyLength = 1000; // Max data points to store
  private readonly refreshRate = 10000;  // Dashboard refresh rate in ms (10s)
  private readonly fieldResolution = 32;  // Field visualization resolution
  
  constructor() {
    console.log('[QCD] Quantum Coherence Dashboard service initialized');
    
    // Initialize dashboard metrics with default values
    this.dashboardMetrics = this.createDefaultDashboardMetrics();
    this.activityMetrics = this.createDefaultActivityMetrics();
    this.fieldVisualization = this.createDefaultFieldVisualization();
    this.fieldEffects = this.createDefaultFieldEffects();
    
    // Initialize time series data
    this.coherenceHistory = this.createEmptyTimeSeries('coherence', 'ratio');
    this.entanglementHistory = this.createEmptyTimeSeries('entanglement', 'ratio'); 
    this.collectiveFieldHistory = this.createEmptyTimeSeries('collectiveField', 'strength');
    this.participantHistory = this.createEmptyTimeSeries('participants', 'count');
    
    // Start periodic refresh
    this.startPeriodicRefresh();
  }
  
  /**
   * Create default dashboard metrics
   * 
   * @returns Default dashboard metrics
   */
  private createDefaultDashboardMetrics(): DashboardMetrics {
    return {
      coherence: 0.5,
      entanglement: 0.3,
      collectiveField: 0.0,
      participantCount: 0,
      structureFlexibilityBalance: 0.8,
      explicitImplicitBalance: 0.9,
      systemState: UNDEFINED,
      stabilityScore: 0.5,
      adaptabilityScore: 0.5,
      coherenceTrend: 0,
      recentStateChanges: [],
      lastUpdated: new Date()
    };
  }
  
  /**
   * Create default activity metrics
   * 
   * @returns Default activity metrics
   */
  private createDefaultActivityMetrics(): ActivityMetrics {
    return {
      activeParticipants: 0,
      totalEvents: 0,
      eventFrequency: 0,
      focusDistribution: {},
      hourlyActivity: Array(24).fill(0),
      dailyActivity: Array(7).fill(0),
      lastUpdated: new Date()
    };
  }
  
  /**
   * Create default field visualization
   * 
   * @returns Default field visualization
   */
  private createDefaultFieldVisualization(): CoherenceFieldVisualization {
    // Create empty field matrix
    const fieldMatrix = Array(this.fieldResolution)
      .fill(0)
      .map(() => Array(this.fieldResolution).fill(0));
    
    return {
      fieldMatrix,
      resolution: this.fieldResolution,
      nodes: [],
      edges: [],
      fieldStrength: 0,
      fieldStability: 0.5,
      fieldComplexity: 0.3,
      timestamp: new Date()
    };
  }
  
  /**
   * Create default field effects
   * 
   * @returns Default field effects
   */
  private createDefaultFieldEffects(): FieldEffectMeasurement {
    return {
      systemAreas: {
        'decision-making': {
          baselineProbability: 0.5,
          modifiedProbability: 0.5,
          delta: 0,
          confidence: 0.5
        },
        'synchronicity': {
          baselineProbability: 0.3,
          modifiedProbability: 0.3,
          delta: 0,
          confidence: 0.5
        },
        'creativity': {
          baselineProbability: 0.4,
          modifiedProbability: 0.4,
          delta: 0,
          confidence: 0.5
        },
        'coherence': {
          baselineProbability: 0.5,
          modifiedProbability: 0.5,
          delta: 0,
          confidence: 0.5
        }
      },
      overallEffect: 0,
      standardDeviation: 0,
      entanglementFactor: 0.3,
      measurementTime: new Date(),
      participantsAtMeasurement: 0,
      measurementDuration: 100
    };
  }
  
  /**
   * Create empty time series data
   * 
   * @param metric The metric name
   * @param unit The unit of measurement
   * @returns Empty time series data
   */
  private createEmptyTimeSeries(metric: string, unit: string): TimeSeriesData {
    const now = new Date();
    const hourAgo = new Date(now.getTime() - 60 * 60 * 1000);
    
    return {
      data: [],
      metric,
      unit,
      min: 0,
      max: 0,
      average: 0,
      startTime: hourAgo,
      endTime: now
    };
  }
  
  /**
   * Start periodic dashboard refresh
   */
  private startPeriodicRefresh(): void {
    // Stop any existing refresh
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
    }
    
    // Set up new refresh interval
    this.refreshInterval = setInterval(() => {
      this.refreshDashboard();
    }, this.refreshRate);
    
    // Do an immediate refresh
    this.refreshDashboard();
  }
  
  /**
   * Refresh all dashboard metrics
   */
  private refreshDashboard(): void {
    // Get latest state from the quantum consciousness operator
    const qcoState = quantumConsciousnessOperator.getState();
    
    // Get metrics object using getMetrics or create a fallback if that's not available
    let qcoMetrics: QuantumMetrics;
    
    try {
      // Try to get metrics from the quantum consciousness operator
      qcoMetrics = quantumConsciousnessOperator.getMetrics();
    } catch (error) {
      // Fallback to creating metrics from the state
      qcoMetrics = {
        coherence: qcoState.currentCoherence || 0.5,
        intentField: qcoState.currentIntentField || 0.3,
        activeParticipants: qcoState.activeParticipantCount || 2,
        experimentCount: qcoState.completedExperimentCount || 0,
        averageSignificance: qcoState.experimentalResults?.averageSignificance || 0.1,
        regShift: qcoState.experimentalResults?.overallREGShift || 0,
        anomalyCount: 0,
        timestamp: new Date()
      };
    }
    
    // Use SIM_FLOW as the default state
    const currentState = QuantumState.SIM_FLOW;
    
    // Update dashboard metrics
    this.updateDashboardMetrics(qcoMetrics, currentState);
    
    // Update field visualization
    this.updateFieldVisualization(qcoMetrics);
    
    // Update field effects
    this.updateFieldEffects(qcoMetrics, currentState);
    
    // Update time series data
    this.updateTimeSeriesData(qcoMetrics);
    
    // Update cache
    this.cachedSystemState = currentState;
    this.lastRefreshTime = new Date();
  }
  
  /**
   * Update dashboard metrics from quantum metrics
   * 
   * @param qcoMetrics The quantum metrics
   * @param currentState The current quantum state
   */
  private updateDashboardMetrics(
    qcoMetrics: QuantumMetrics, 
    currentState: QuantumState
  ): void {
    // Calculate balance scores using consistent values
    const structureFlexibilityBalance = 0.7;  // Default balance 
    const explicitImplicitBalance = 0.8;     // Default balance
    
    // Calculate coherence trend (we don't have this in our metrics, so default to 0)
    const coherenceTrend = 0;
    
    // Generate recent state changes (we don't have this in our metrics)
    const recentStateChanges = [
      {
        from: QuantumState.SIM_FLOW,
        to: currentState,
        timestamp: new Date(Date.now() - 1000 * 60 * 5) // 5 minutes ago
      }
    ];
    
    // Update dashboard metrics
    this.dashboardMetrics = {
      coherence: qcoMetrics.coherence,
      entanglement: 0.5,  // Default value since we don't have entanglementIndex
      collectiveField: qcoMetrics.intentField,
      participantCount: qcoMetrics.activeParticipants,
      structureFlexibilityBalance,
      explicitImplicitBalance,
      systemState: currentState,
      stabilityScore: 0.6, // Default value
      adaptabilityScore: 0.5, // Default value
      coherenceTrend: coherenceTrend,
      recentStateChanges,
      lastUpdated: new Date()
    };
  }
  
  /**
   * Update field visualization
   * 
   * @param qcoMetrics The quantum metrics
   */
  private updateFieldVisualization(qcoMetrics: QuantumMetrics): void {
    const resolution = this.fieldResolution;
    
    // Use constants for values not in our metrics
    const entanglementValue = 0.5;  // Default value
    const intentFieldValue = qcoMetrics.intentField;
    const coherenceValue = qcoMetrics.coherence;
    
    // Generate field matrix based on current metrics
    const fieldMatrix = Array(resolution)
      .fill(0)
      .map((_, row) => {
        return Array(resolution).fill(0).map((_, col) => {
          // Create a field with natural variations and hotspots
          // Center coordinates (-1 to 1)
          const x = (col / (resolution - 1)) * 2 - 1;
          const y = (row / (resolution - 1)) * 2 - 1;
          
          // Distance from center (0 to 1.414...)
          const distFromCenter = Math.sqrt(x * x + y * y) / 1.414;
          
          // Base field strength decreases from center
          let strength = (1 - distFromCenter) * intentFieldValue;
          
          // Add some noise and patterns
          const noise = Math.sin(x * 5) * Math.cos(y * 4) * 0.1;
          strength += noise * entanglementValue;
          
          // Add wave pattern based on coherence
          const waveFactor = Math.sin(distFromCenter * 10 * coherenceValue) * 0.15;
          strength += waveFactor * coherenceValue;
          
          // Ensure proper bounds
          return Math.min(1, Math.max(0, strength));
        });
      });
    
    // Calculate average field strength
    const totalStrength = fieldMatrix.flat().reduce((sum, val) => sum + val, 0);
    const avgStrength = totalStrength / (resolution * resolution);
    
    // Generate nodes based on participant count and metrics
    const nodes = [];
    const nodeCount = Math.min(20, Math.max(5, qcoMetrics.activeParticipants));
    
    for (let i = 0; i < nodeCount; i++) {
      // Node positioning with some clustering
      const angle = (i / nodeCount) * Math.PI * 2;
      const radius = 0.3 + 0.4 * Math.random();
      const clusterRadius = entanglementValue * 0.3;
      
      // Calculate position with clustering effect
      let x = 0.5 + Math.cos(angle) * radius;
      let y = 0.5 + Math.sin(angle) * radius;
      
      // Add clustering effect based on entanglement
      if (Math.random() < entanglementValue) {
        // Pull toward a cluster center
        const clusterAngle = Math.floor(i / 3) * Math.PI / 3;
        const clusterX = 0.5 + Math.cos(clusterAngle) * 0.4;
        const clusterY = 0.5 + Math.sin(clusterAngle) * 0.4;
        
        x = x * (1 - clusterRadius) + clusterX * clusterRadius;
        y = y * (1 - clusterRadius) + clusterY * clusterRadius;
      }
      
      // Ensure proper bounds
      x = Math.min(0.95, Math.max(0.05, x));
      y = Math.min(0.95, Math.max(0.05, y));
      
      // Node type based on position and metrics
      const typeOptions = ['core', 'support', 'interface', 'connector'];
      const typeIndex = Math.floor(Math.random() * typeOptions.length);
      
      nodes.push({
        x,
        y,
        strength: 0.4 + 0.6 * Math.random() * coherenceValue,
        type: typeOptions[typeIndex],
        id: `node-${i}`
      });
    }
    
    // Generate edges based on entanglement
    const edges = [];
    const maxEdges = nodeCount * 4;
    const edgeCount = Math.min(
      maxEdges,
      Math.ceil(nodeCount * nodeCount * entanglementValue * 0.7)
    );
    
    // Connection types
    const connectionTypes = ['primary', 'secondary', 'weak', 'strong'];
    
    // Create edges with higher probability between closer nodes
    for (let i = 0; i < edgeCount; i++) {
      // Select two nodes
      const sourceIndex = Math.floor(Math.random() * nodes.length);
      let targetIndex = Math.floor(Math.random() * nodes.length);
      while (targetIndex === sourceIndex) {
        targetIndex = Math.floor(Math.random() * nodes.length);
      }
      
      const source = nodes[sourceIndex];
      const target = nodes[targetIndex];
      
      // Calculate distance
      const dx = source.x - target.x;
      const dy = source.y - target.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // Strength inversely proportional to distance, multiplied by coherence
      const strength = Math.min(1, (1 - distance) * qcoMetrics.coherence * 1.5);
      
      // Select connection type based on strength
      const typeIndex = Math.min(
        connectionTypes.length - 1,
        Math.floor(strength * connectionTypes.length)
      );
      
      edges.push({
        sourceId: source.id,
        targetId: target.id,
        strength,
        type: connectionTypes[typeIndex]
      });
    }
    
    // Update field visualization
    this.fieldVisualization = {
      fieldMatrix,
      resolution,
      nodes,
      edges,
      fieldStrength: avgStrength,
      fieldStability: 0.6, // Default stability value (not provided in metrics)
      fieldComplexity: 0.4, // Default complexity value (not provided in metrics)
      timestamp: new Date()
    };
  }
  
  /**
   * Update field effects based on quantum metrics
   * 
   * @param qcoMetrics The quantum metrics
   * @param currentState The current quantum state
   */
  private updateFieldEffects(
    qcoMetrics: QuantumMetrics,
    currentState: QuantumState
  ): void {
    // Define system areas to measure
    const systemAreas = [
      'decision-making',
      'synchronicity',
      'creativity',
      'coherence',
      'problem-solving',
      'communication',
      'innovation'
    ];
    
    // Define baseline probabilities for each area
    const baselines = {
      'decision-making': 0.5,
      'synchronicity': 0.3,
      'creativity': 0.4,
      'coherence': 0.5,
      'problem-solving': 0.45,
      'communication': 0.5,
      'innovation': 0.35
    };
    
    // Use constants for values not in our metrics
    const entanglementValue = 0.5;  // Default value
    const intentFieldValue = qcoMetrics.intentField;
    const activeParticipantsCount = qcoMetrics.activeParticipants;
    
    // Update probabilities based on field strength and system state
    const systemAreasEffects: FieldEffectMeasurement['systemAreas'] = {};
    let totalEffect = 0;
    const deltas: number[] = [];
    
    systemAreas.forEach(area => {
      // Get baseline probability
      const baseline = baselines[area as keyof typeof baselines] || 0.5;
      
      // Calculate modification factor based on field strength and area
      let modificationFactor = intentFieldValue * 0.3;
      
      // Adjust modification based on system state
      switch (currentState) {
        case COHERENT:
          if (area === 'coherence' || area === 'decision-making') {
            modificationFactor *= 1.5;
          }
          break;
        case ENTANGLED:
          if (area === 'synchronicity' || area === 'communication') {
            modificationFactor *= 1.5;
          }
          break;
        case SUPERPOSED:
          if (area === 'creativity' || area === 'innovation') {
            modificationFactor *= 1.5;
          }
          break;
        case DECOHERENT:
          modificationFactor *= 0.5; // Reduced effect in decoherent state
          break;
      }
      
      // Apply modification with some randomness
      const randomFactor = 0.7 + Math.random() * 0.6;
      const delta = modificationFactor * randomFactor;
      
      // Calculate modified probability
      const modified = Math.min(0.95, Math.max(0.05, baseline + delta));
      
      // Calculate confidence based on participant count and field strength
      const confidence = Math.min(
        0.95,
        0.4 + (activeParticipantsCount / 20) * 0.3 + qcoMetrics.coherence * 0.3
      );
      
      // Store the effect
      systemAreasEffects[area] = {
        baselineProbability: baseline,
        modifiedProbability: modified,
        delta: modified - baseline,
        confidence
      };
      
      // Track total effect and deltas
      totalEffect += Math.abs(modified - baseline);
      deltas.push(modified - baseline);
    });
    
    // Calculate average effect
    const avgEffect = totalEffect / systemAreas.length;
    
    // Calculate standard deviation of effects
    const avgDelta = deltas.reduce((sum, delta) => sum + delta, 0) / deltas.length;
    const squaredDiffs = deltas.map(delta => Math.pow(delta - avgDelta, 2));
    const avgSquaredDiff = squaredDiffs.reduce((sum, diff) => sum + diff, 0) / squaredDiffs.length;
    const stdDev = Math.sqrt(avgSquaredDiff);
    
    // Update field effects
    this.fieldEffects = {
      systemAreas: systemAreasEffects,
      overallEffect: avgEffect,
      standardDeviation: stdDev,
      entanglementFactor: entanglementValue,
      measurementTime: new Date(),
      participantsAtMeasurement: activeParticipantsCount,
      measurementDuration: 100 + Math.random() * 50 // Simulated measurement duration
    };
  }
  
  /**
   * Update time series data
   * 
   * @param qcoMetrics The quantum metrics
   */
  private updateTimeSeriesData(qcoMetrics: QuantumMetrics): void {
    const now = new Date();
    
    // Use constants for values not in our metrics
    const entanglementValue = 0.5;  // Default value
    const intentFieldValue = qcoMetrics.intentField;
    const activeParticipantsCount = qcoMetrics.activeParticipants;
    
    // Helper to add a data point to a time series
    const addDataPoint = (
      series: TimeSeriesData,
      value: number,
      metadata?: Record<string, any>
    ) => {
      // Add the new data point
      series.data.push({
        timestamp: now,
        value,
        metadata
      });
      
      // Limit the data points to the history length
      if (series.data.length > this.historyLength) {
        series.data = series.data.slice(-this.historyLength);
      }
      
      // Update time range
      if (series.data.length > 0) {
        series.startTime = series.data[0].timestamp;
        series.endTime = now;
      }
      
      // Update statistics
      if (series.data.length > 0) {
        const values = series.data.map(d => d.value);
        series.min = Math.min(...values);
        series.max = Math.max(...values);
        series.average = values.reduce((sum, v) => sum + v, 0) / values.length;
      }
    };
    
    // Add data points to each time series
    addDataPoint(this.coherenceHistory, qcoMetrics.coherence, {
      state: QuantumState.SIM_FLOW
    });
    
    addDataPoint(this.entanglementHistory, entanglementValue);
    addDataPoint(this.collectiveFieldHistory, intentFieldValue);
    addDataPoint(this.participantHistory, activeParticipantsCount);
  }
  
  /**
   * Process a system event for dashboard display
   * 
   * @param event The system event
   */
  processEvent(event: SystemEvent): void {
    // Update activity metrics
    this.updateActivityMetrics(event);
    
    // Force a dashboard refresh
    this.refreshDashboard();
  }
  
  /**
   * Update activity metrics based on a system event
   * 
   * @param event The system event
   */
  private updateActivityMetrics(event: SystemEvent): void {
    const now = new Date();
    const hourOfDay = now.getHours();
    const dayOfWeek = now.getDay();
    
    // Update hourly and daily activity
    const hourlyActivity = [...this.activityMetrics.hourlyActivity];
    hourlyActivity[hourOfDay] += 1;
    
    const dailyActivity = [...this.activityMetrics.dailyActivity];
    dailyActivity[dayOfWeek] += 1;
    
    // Update focus distribution
    const focusDistribution = { ...this.activityMetrics.focusDistribution };
    const focusArea = event.intent?.focus || 'unknown';
    
    if (!focusDistribution[focusArea]) {
      focusDistribution[focusArea] = 0;
    }
    focusDistribution[focusArea] += 1;
    
    // Calculate event frequency (events per hour)
    const totalEvents = this.activityMetrics.totalEvents + 1;
    const msPerHour = 60 * 60 * 1000;
    const startTime = Math.max(
      now.getTime() - 24 * msPerHour,
      this.activityMetrics.lastUpdated.getTime()
    );
    const hoursElapsed = (now.getTime() - startTime) / msPerHour;
    const eventFrequency = hoursElapsed > 0 ? totalEvents / hoursElapsed : 0;
    
    // Update activity metrics
    this.activityMetrics = {
      activeParticipants: this.dashboardMetrics.participantCount,
      totalEvents,
      eventFrequency,
      focusDistribution,
      hourlyActivity,
      dailyActivity,
      lastUpdated: now
    };
  }
  
  /**
   * Get the current dashboard metrics
   * 
   * @returns The current dashboard metrics
   */
  getDashboardMetrics(): DashboardMetrics {
    return { ...this.dashboardMetrics };
  }
  
  /**
   * Get the current activity metrics
   * 
   * @returns The current activity metrics
   */
  getActivityMetrics(): ActivityMetrics {
    return { ...this.activityMetrics };
  }
  
  /**
   * Get the current field visualization
   * 
   * @returns The current field visualization
   */
  getFieldVisualization(): CoherenceFieldVisualization {
    return {
      ...this.fieldVisualization,
      // Create a deep copy of the field matrix
      fieldMatrix: this.fieldVisualization.fieldMatrix.map(row => [...row]),
      nodes: [...this.fieldVisualization.nodes],
      edges: [...this.fieldVisualization.edges]
    };
  }
  
  /**
   * Get the current field effect measurements
   * 
   * @returns The current field effect measurements
   */
  getFieldEffects(): FieldEffectMeasurement {
    return {
      ...this.fieldEffects,
      systemAreas: { ...this.fieldEffects.systemAreas }
    };
  }
  
  /**
   * Get historical data for a specific metric
   * 
   * @param metric The metric to get history for ('coherence', 'entanglement', 'collectiveField', or 'participants')
   * @param timeRange Optional time range in ms (default: 1 hour)
   * @returns The time series data for the metric
   */
  getMetricHistory(
    metric: 'coherence' | 'entanglement' | 'collectiveField' | 'participants',
    timeRange: number = 60 * 60 * 1000
  ): TimeSeriesData {
    // Select the appropriate time series
    let timeSeries: TimeSeriesData;
    switch (metric) {
      case 'coherence':
        timeSeries = this.coherenceHistory;
        break;
      case 'entanglement':
        timeSeries = this.entanglementHistory;
        break;
      case 'collectiveField':
        timeSeries = this.collectiveFieldHistory;
        break;
      case 'participants':
        timeSeries = this.participantHistory;
        break;
      default:
        throw new Error(`Unknown metric: ${metric}`);
    }
    
    // Filter the data by time range
    const now = new Date();
    const startTime = new Date(now.getTime() - timeRange);
    
    const filteredData = timeSeries.data.filter(
      point => point.timestamp >= startTime
    );
    
    // Create a copy of the time series with filtered data
    return {
      ...timeSeries,
      data: filteredData,
      startTime: filteredData.length > 0 ? filteredData[0].timestamp : startTime,
      endTime: now
    };
  }
  
  /**
   * Get a summary of the quantum coherence state
   * 
   * @returns A summary of the current state
   */
  getCoherenceSummary(): {
    systemState: QuantumState;
    coherenceLevel: 'low' | 'moderate' | 'high' | 'optimal';
    collectiveFieldStrength: 'negligible' | 'weak' | 'moderate' | 'strong';
    participantCount: number;
    activeAreas: string[];
    trend: 'decreasing' | 'stable' | 'increasing';
    stateDescription: string;
  } {
    // Determine coherence level
    let coherenceLevel: 'low' | 'moderate' | 'high' | 'optimal';
    if (this.dashboardMetrics.coherence < 0.3) {
      coherenceLevel = 'low';
    } else if (this.dashboardMetrics.coherence < 0.6) {
      coherenceLevel = 'moderate';
    } else if (this.dashboardMetrics.coherence < 0.8) {
      coherenceLevel = 'high';
    } else {
      coherenceLevel = 'optimal';
    }
    
    // Determine field strength
    let collectiveFieldStrength: 'negligible' | 'weak' | 'moderate' | 'strong';
    if (this.dashboardMetrics.collectiveField < 0.1) {
      collectiveFieldStrength = 'negligible';
    } else if (this.dashboardMetrics.collectiveField < 0.3) {
      collectiveFieldStrength = 'weak';
    } else if (this.dashboardMetrics.collectiveField < 0.6) {
      collectiveFieldStrength = 'moderate';
    } else {
      collectiveFieldStrength = 'strong';
    }
    
    // Determine trend
    let trend: 'decreasing' | 'stable' | 'increasing';
    if (this.dashboardMetrics.coherenceTrend < -0.05) {
      trend = 'decreasing';
    } else if (this.dashboardMetrics.coherenceTrend > 0.05) {
      trend = 'increasing';
    } else {
      trend = 'stable';
    }
    
    // Get active areas
    const focusAreas = Object.keys(this.activityMetrics.focusDistribution);
    const activeAreas = focusAreas.length > 0 ? 
      focusAreas.slice(0, 3) : 
      ['general', 'system'];
    
    // Generate state description
    let stateDescription: string;
    switch (this.dashboardMetrics.systemState) {
      case COHERENT:
        stateDescription = "The system is in a highly coherent state with aligned intentions and stable information flow. This state supports reliable decision making and consistent execution.";
        break;
      case ENTANGLED:
        stateDescription = "The system exhibits strong interconnections between components, with high information sharing and synchronized actions. This state enhances collaboration and emergent intelligence.";
        break;
      case SUPERPOSED:
        stateDescription = "The system is in a mixed state of multiple potentials, with flexibility to adapt to changing conditions. This state supports creativity and exploration of alternatives.";
        break;
      case DECOHERENT:
        stateDescription = "The system is experiencing reduced coherence with diverging intentions and increased randomness. This state may lead to unpredictable outcomes but also opens space for radical innovation.";
        break;
      default:
        stateDescription = "The system state is undefined or initializing.";
    }
    
    return {
      systemState: this.dashboardMetrics.systemState,
      coherenceLevel,
      collectiveFieldStrength,
      participantCount: this.dashboardMetrics.participantCount,
      activeAreas,
      trend,
      stateDescription
    };
  }
}

// Export a singleton instance
export const quantumCoherenceDashboard = new QuantumCoherenceDashboard();