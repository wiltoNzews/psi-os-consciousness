/**
 * Quantum Variant Tracker - "Loki Variants" System
 * [QUANTUM_STATE: BIFURCATION_FLOW]
 * 
 * This file implements the Loki Variant system that tracks and manages
 * variants generated at θ=0.5 by the Quantum Bifurcation Engine.
 * 
 * Key capabilities:
 * - Detects variant generation events at θ=0.5
 * - Tracks variant lifecycles and performance
 * - Manages cross-variant resonance (5D orchestration)
 * - Broadcasts variant events via WebSockets
 */

import { v4 as uuidv4 } from 'uuid';
import { QCTFParams, QCTFResults } from '../../../shared/qctf-plugins.js';
import { QuantumToggles } from '../../../shared/qctf-toggles.js';
import { broadcastEvent } from '../../ws-handlers/quantum-handlers.js';

/**
 * Variant generation threshold (how close to θ=0.5 is needed)
 */
const VARIANT_GENERATION_THRESHOLD = 0.05;

/**
 * Variant resonance threshold (minimum resonance for cross-variant connection)
 */
const RESONANCE_THRESHOLD = 0.7;

/**
 * Status of a Loki Variant 
 */
export type VariantStatus = 
  | 'nascent'    // Newly generated, not yet stable
  | 'stable'     // Stable and operational
  | 'resonating' // Actively resonating with other variants
  | 'unstable'   // Becoming unstable, may collapse
  | 'collapsed'  // Collapsed, no longer active
  | 'dormant';   // Inactive but still tracked

/**
 * Interface representing a quantum bifurcation variant ("Loki Variant")
 */
export interface QuantumVariant {
  id: string;               // Unique variant ID
  name: string;             // Human-readable name
  status: VariantStatus;    // Current status
  birthTime: string;        // ISO timestamp of generation
  parentId: string | null;  // ID of parent variant (if any)
  thetaValue: number;       // θ value at generation time
  createdAt: string;        // ISO timestamp of creation
  updatedAt: string;        // ISO timestamp of last update
  
  // Core parameters
  coherenceIndex: number;   // Internal coherence (0-1)
  stabilityIndex: number;   // Current stability (0-1)
  entropyLevel: number;     // Current entropy level (0-1)
  
  // Performance metrics
  successRate: number;      // Success rate for operations (0-1)
  adaptationRate: number;   // Rate of successful adaptation (0-1)
  cumulativeValue: number;  // Cumulative business value generated
  
  // Active capabilities
  activePlugins: string[];  // List of active plugins
  activeToggles: string[];  // Active toggles
  
  // Resonance connections (5D meta-orchestration)
  connectedVariants: {      // Variants this variant is resonating with
    variantId: string;      // Connected variant ID
    strength: number;       // Connection strength (0-1)
    resonanceType: string;  // Type of resonance
  }[];
}

/**
 * Event indicating a variant generation, resonance, or other significant event
 */
export interface VariantEvent {
  id: string;                  // Unique event ID
  type: string;                // Event type
  timestamp: string;           // ISO timestamp
  variantId: string;           // ID of primary variant involved
  relatedVariantId?: string;   // ID of related variant (if any)
  thetaValue: number;          // θ value at event time
  description: string;         // Human-readable description
  metrics: Record<string, any>; // Associated metrics
}

/**
 * Class responsible for tracking quantum variants generated by the bifurcation engine
 */
export class VariantTracker {
  private variants: Map<string, QuantumVariant>;
  private events: VariantEvent[];
  private activeVariantId: string | null;
  
  constructor() {
    this.variants = new Map();
    this.events = [];
    this.activeVariantId = null;
    
    // Create the baseline "prime" variant that always exists
    this.createPrimeVariant();
  }
  
  /**
   * Create the prime (baseline) variant that serves as the root of the variant tree
   */
  private createPrimeVariant(): void {
    const now = new Date().toISOString();
    const primeId = 'prime-variant-' + uuidv4();
    
    const primeVariant: QuantumVariant = {
      id: primeId,
      name: 'Prime Variant',
      status: 'stable',
      birthTime: now,
      parentId: null,
      thetaValue: 0.3, // Standard balanced state, slightly ordered
      createdAt: now,
      updatedAt: now,
      
      coherenceIndex: 0.9,
      stabilityIndex: 0.95,
      entropyLevel: 0.2,
      
      successRate: 1.0,
      adaptationRate: 0.8,
      cumulativeValue: 1000,
      
      activePlugins: ['pendulum'],
      activeToggles: [],
      
      connectedVariants: []
    };
    
    this.variants.set(primeId, primeVariant);
    this.activeVariantId = primeId;
    
    // Log the creation event
    this.logEvent({
      id: uuidv4(),
      type: 'variant_created',
      timestamp: now,
      variantId: primeId,
      thetaValue: 0.3,
      description: 'Prime Variant initialized as system baseline',
      metrics: {
        coherence: 0.9,
        stability: 0.95,
        entropy: 0.2
      }
    });
  }
  
  /**
   * Log a variant-related event and broadcast via WebSockets
   */
  private logEvent(event: VariantEvent): void {
    this.events.push(event);
    
    // Broadcast via WebSockets for real-time monitoring
    broadcastEvent('qctf_variant_event', {
      ...event,
      activeVariantId: this.activeVariantId
    });
    
    // Trim event history if it gets too large
    if (this.events.length > 1000) {
      this.events = this.events.slice(-500);
    }
  }
  
  /**
   * Check if a variant should be generated based on the current QCTF state
   * Primarily triggered when θ is close to 0.5 (the bifurcation point)
   */
  public checkVariantGeneration(
    params: QCTFParams, 
    results: QCTFResults, 
    toggles: QuantumToggles
  ): string | null {
    // Check if we're near the bifurcation point (θ = 0.5)
    const distanceFromBifurcation = Math.abs(params.theta - 0.5);
    
    // Only generate variants near θ=0.5 and when the bifurcation plugin is active
    if (
      distanceFromBifurcation <= VARIANT_GENERATION_THRESHOLD && 
      results.activePlugins.includes('bifurcation')
    ) {
      // Calculate the probability of variant generation
      // Increases as θ approaches exactly 0.5
      const generationProbability = 
        1 - (distanceFromBifurcation / VARIANT_GENERATION_THRESHOLD);
      
      // Add randomness to make generation probabilistic
      if (Math.random() < generationProbability * 0.3) { // 30% max chance
        return this.generateVariant(params, results, toggles);
      }
    }
    
    return null;
  }
  
  /**
   * Generate a new Loki Variant based on current system state
   */
  private generateVariant(
    params: QCTFParams, 
    results: QCTFResults, 
    toggles: QuantumToggles
  ): string {
    const now = new Date().toISOString();
    const variantId = 'loki-variant-' + uuidv4();
    
    // Determine active toggles
    const activeToggles = Object.entries(toggles)
      .filter(([_, state]) => state.active)
      .map(([name, _]) => name);
    
    // Generate a name based on dominant characteristics
    const entropyFactor = params.entropy > 0.5 ? 'Chaotic' : 'Ordered';
    const coherenceFactor = params.ci > 0.7 ? 'Coherent' : 'Divergent';
    const variantName = `${entropyFactor} ${coherenceFactor} Variant`;
    
    // Create the variant with inherited and mutated properties
    const newVariant: QuantumVariant = {
      id: variantId,
      name: variantName,
      status: 'nascent',
      birthTime: now,
      parentId: this.activeVariantId,
      thetaValue: params.theta,
      createdAt: now,
      updatedAt: now,
      
      // Core parameters - slightly mutated from current state
      coherenceIndex: params.ci * (0.8 + Math.random() * 0.4),
      stabilityIndex: 0.5 + Math.random() * 0.3, // New variants start moderately stable
      entropyLevel: params.entropy * (0.8 + Math.random() * 0.4),
      
      // Performance metrics - start cautiously
      successRate: 0.7 + Math.random() * 0.2,
      adaptationRate: 0.6 + Math.random() * 0.3,
      cumulativeValue: 0,
      
      // Active capabilities - inherit with potential mutations
      activePlugins: [...results.activePlugins],
      activeToggles,
      
      // Start with connection to parent
      connectedVariants: this.activeVariantId 
        ? [{
            variantId: this.activeVariantId,
            strength: 0.8,
            resonanceType: 'parent-child'
          }] 
        : []
    };
    
    // Add the variant to the tracker
    this.variants.set(variantId, newVariant);
    
    // Log the generation event
    this.logEvent({
      id: uuidv4(),
      type: 'variant_generated',
      timestamp: now,
      variantId,
      relatedVariantId: this.activeVariantId || undefined,
      thetaValue: params.theta,
      description: `Generated Loki Variant "${variantName}" at θ=${params.theta.toFixed(3)}`,
      metrics: {
        bifurcationResult: results.bifurcation,
        coherence: newVariant.coherenceIndex,
        stability: newVariant.stabilityIndex,
        entropy: newVariant.entropyLevel
      }
    });
    
    return variantId;
  }
  
  /**
   * Update an existing variant's status and metrics
   */
  public updateVariant(
    variantId: string,
    updates: Partial<QuantumVariant>
  ): QuantumVariant | null {
    const variant = this.variants.get(variantId);
    if (!variant) return null;
    
    // Apply updates
    const updatedVariant = {
      ...variant,
      ...updates,
      updatedAt: new Date().toISOString()
    };
    
    // Store the updated variant
    this.variants.set(variantId, updatedVariant);
    
    // Log the update event
    this.logEvent({
      id: uuidv4(),
      type: 'variant_updated',
      timestamp: updatedVariant.updatedAt,
      variantId,
      thetaValue: updatedVariant.thetaValue,
      description: `Updated variant "${updatedVariant.name}" status: ${updatedVariant.status}`,
      metrics: {
        coherence: updatedVariant.coherenceIndex,
        stability: updatedVariant.stabilityIndex,
        entropy: updatedVariant.entropyLevel,
        successRate: updatedVariant.successRate
      }
    });
    
    return updatedVariant;
  }
  
  /**
   * Activate a specific variant as the primary system state
   */
  public activateVariant(variantId: string): boolean {
    const variant = this.variants.get(variantId);
    if (!variant) return false;
    
    const previousVariantId = this.activeVariantId;
    this.activeVariantId = variantId;
    
    // Log the activation event
    this.logEvent({
      id: uuidv4(),
      type: 'variant_activated',
      timestamp: new Date().toISOString(),
      variantId,
      relatedVariantId: previousVariantId || undefined,
      thetaValue: variant.thetaValue,
      description: `Activated Loki Variant "${variant.name}" as primary system state`,
      metrics: {
        coherence: variant.coherenceIndex,
        stability: variant.stabilityIndex,
        entropy: variant.entropyLevel,
        successRate: variant.successRate
      }
    });
    
    return true;
  }
  
  /**
   * Check for and establish resonance between variants
   * This implements the 5D meta-orchestration layer
   */
  public checkVariantResonance(): void {
    // Skip if less than 2 variants exist
    if (this.variants.size < 2) return;
    
    const variantArray = Array.from(this.variants.values());
    
    // Check each variant pair for potential resonance
    for (let i = 0; i < variantArray.length; i++) {
      for (let j = i + 1; j < variantArray.length; j++) {
        const variantA = variantArray[i];
        const variantB = variantArray[j];
        
        // Skip if either variant is collapsed or dormant
        if (
          variantA.status === 'collapsed' ||
          variantA.status === 'dormant' ||
          variantB.status === 'collapsed' ||
          variantB.status === 'dormant'
        ) {
          continue;
        }
        
        // Calculate resonance potential based on complementarity
        const resonancePotential = this.calculateResonance(variantA, variantB);
        
        // If resonance exceeds threshold, establish connection
        if (resonancePotential >= RESONANCE_THRESHOLD) {
          this.establishResonance(variantA, variantB, resonancePotential);
        }
      }
    }
  }
  
  /**
   * Calculate resonance potential between two variants
   * Higher values indicate stronger complementary capabilities
   */
  private calculateResonance(variantA: QuantumVariant, variantB: QuantumVariant): number {
    // Check if they're already connected
    const existingConnection = variantA.connectedVariants.find(
      c => c.variantId === variantB.id
    );
    
    if (existingConnection) {
      return existingConnection.strength;
    }
    
    // Base resonance on complementary properties
    // Strong resonance comes from opposite entropy but similar coherence
    const entropyComplementarity = 1 - Math.abs(
      (variantA.entropyLevel + variantB.entropyLevel) - 1
    );
    
    const coherenceSimilarity = 1 - Math.abs(
      variantA.coherenceIndex - variantB.coherenceIndex
    );
    
    // Shared plugins increase resonance
    const sharedPlugins = variantA.activePlugins.filter(
      p => variantB.activePlugins.includes(p)
    );
    const pluginSimilarity = sharedPlugins.length / 
      Math.max(variantA.activePlugins.length, variantB.activePlugins.length);
    
    // Calculate resonance score - weighted average of factors
    return (
      (entropyComplementarity * 0.4) +
      (coherenceSimilarity * 0.3) +
      (pluginSimilarity * 0.3)
    );
  }
  
  /**
   * Establish resonance (connection) between two variants
   * This enables cross-variant influence and 5D meta-orchestration
   */
  private establishResonance(
    variantA: QuantumVariant, 
    variantB: QuantumVariant, 
    strength: number
  ): void {
    const now = new Date().toISOString();
    
    // Determine resonance type
    const resonanceType = this.determineResonanceType(variantA, variantB);
    
    // Check if connection already exists in either variant
    const existingInA = variantA.connectedVariants.findIndex(
      c => c.variantId === variantB.id
    );
    
    const existingInB = variantB.connectedVariants.findIndex(
      c => c.variantId === variantA.id
    );
    
    // Update or create connection in variant A
    if (existingInA >= 0) {
      variantA.connectedVariants[existingInA].strength = strength;
      variantA.connectedVariants[existingInA].resonanceType = resonanceType;
    } else {
      variantA.connectedVariants.push({
        variantId: variantB.id,
        strength,
        resonanceType
      });
    }
    
    // Update or create connection in variant B
    if (existingInB >= 0) {
      variantB.connectedVariants[existingInB].strength = strength;
      variantB.connectedVariants[existingInB].resonanceType = resonanceType;
    } else {
      variantB.connectedVariants.push({
        variantId: variantA.id,
        strength,
        resonanceType
      });
    }
    
    // Update both variants in the map
    this.variants.set(variantA.id, {
      ...variantA,
      status: 'resonating',
      updatedAt: now
    });
    
    this.variants.set(variantB.id, {
      ...variantB,
      status: 'resonating',
      updatedAt: now
    });
    
    // Log the resonance event
    this.logEvent({
      id: uuidv4(),
      type: 'variant_resonance',
      timestamp: now,
      variantId: variantA.id,
      relatedVariantId: variantB.id,
      thetaValue: (variantA.thetaValue + variantB.thetaValue) / 2,
      description: `Established ${resonanceType} resonance between variants "${variantA.name}" and "${variantB.name}"`,
      metrics: {
        strength,
        mutualCoherence: (variantA.coherenceIndex + variantB.coherenceIndex) / 2,
        entropyBalance: Math.abs(variantA.entropyLevel - variantB.entropyLevel)
      }
    });
  }
  
  /**
   * Determine the type of resonance between two variants
   */
  private determineResonanceType(variantA: QuantumVariant, variantB: QuantumVariant): string {
    // Parent-child relationship
    if (variantA.parentId === variantB.id || variantB.parentId === variantA.id) {
      return 'parent-child';
    }
    
    // Sibling relationship (same parent)
    if (variantA.parentId && variantA.parentId === variantB.parentId) {
      return 'sibling';
    }
    
    // Entropy-based relationship
    if (Math.abs(variantA.entropyLevel - variantB.entropyLevel) > 0.5) {
      return 'complementary';
    }
    
    // Coherence-based relationship
    if (Math.abs(variantA.coherenceIndex - variantB.coherenceIndex) < 0.2) {
      return 'harmonic';
    }
    
    // Default relationship
    return 'quantum';
  }
  
  /**
   * Get all tracked variants
   */
  public getAllVariants(): QuantumVariant[] {
    return Array.from(this.variants.values());
  }
  
  /**
   * Get a specific variant by ID
   */
  public getVariant(variantId: string): QuantumVariant | null {
    return this.variants.get(variantId) || null;
  }
  
  /**
   * Get the currently active variant
   */
  public getActiveVariant(): QuantumVariant | null {
    return this.activeVariantId 
      ? this.variants.get(this.activeVariantId) || null
      : null;
  }
  
  /**
   * Get recent variant events
   */
  public getRecentEvents(limit: number = 100): VariantEvent[] {
    return this.events.slice(-limit);
  }
  
  /**
   * Create a YAML representation of a variant (for export/import)
   */
  public generateVariantYAML(variantId: string): string {
    const variant = this.variants.get(variantId);
    if (!variant) return '';
    
    // Create plugin configuration strings
    const pluginConfigs = variant.activePlugins.map(plugin => 
      `  - ${plugin}: True`
    ).join('\n');
    
    // Create inactive plugin strings
    const standardPlugins = ['pendulum', 'bifurcation', 'dynamicDamping'];
    const inactivePlugins = standardPlugins
      .filter(p => !variant.activePlugins.includes(p))
      .map(plugin => `  - ${plugin}: False`)
      .join('\n');
    
    // Generate a YAML representation
    return `variant_name: "${variant.name}"
base_qctf_core: True
enabled_plugins:
${pluginConfigs}
${inactivePlugins}
θ_value: ${variant.thetaValue.toFixed(3)}
description: "${variant.name} - ${variant.status} variant with ${variant.entropyLevel.toFixed(2)} entropy"
`;
  }
}

/**
 * Create the global variant tracker instance
 */
export const variantTracker = new VariantTracker();

/**
 * Process QCTF calculation results to check for variant generation
 */
export function processQCTFForVariants(
  params: QCTFParams, 
  results: QCTFResults, 
  toggles: QuantumToggles
): void {
  // Check if we should generate a variant
  const newVariantId = variantTracker.checkVariantGeneration(params, results, toggles);
  
  // If a new variant was generated, broadcast an event
  if (newVariantId) {
    const newVariant = variantTracker.getVariant(newVariantId);
    if (newVariant) {
      broadcastEvent('qctf_variant_generated', {
        variantId: newVariantId,
        name: newVariant.name,
        timestamp: new Date().toISOString(),
        thetaValue: params.theta,
        metrics: {
          coherence: newVariant.coherenceIndex,
          stability: newVariant.stabilityIndex,
          entropy: newVariant.entropyLevel
        }
      });
    }
  }
  
  // Check for resonance between variants periodically
  // (throttled to avoid excessive computation)
  if (Math.random() < 0.1) { // 10% chance per QCTF calculation
    variantTracker.checkVariantResonance();
  }
}